{
  "hash": "e4991ad9ef58e132eabebb0c3fb9d210",
  "result": {
    "markdown": "---\ntitle: \"Process data using apply function\"\nauthor: \"Sougata Maity\"\ndate: \"2023-08-01\"\ncategories: [python, Data analysis, R Code, Statistics]\nimage: \"banner.png\"\nsubtitle: \"Use apply function to process data row-wise or column-wise efficiently.\"\n---\n\n::: {.cell}\n<style type=\"text/css\">\n.justify {\n  text-align: justify !important\n}\n</style>\n:::\n\n\n::: justify\nApply function one of the most important to row or column manipulation to apply a function to either rows or columns of a matrix or data frame. The apply function is a powerful tool for performing operations across rows or columns efficiently.\n\nThe primary purpose of using a row-wise apply function is to perform element-wise operations or computations on individual rows of the data and generate new values or summaries based on the row-level data.\n\nHere are a few common use cases and benefits of using row-wise apply functions:\n\n1.  Element-wise operations: Sometimes, you need to perform calculations or transformations on elements within a row independently of other rows. Using a row-wise apply function allows you to conveniently apply a function to each row, processing the elements in isolation.\n\n2.  Feature engineering: When working with datasets, you might need to create new features based on existing ones. A row-wise apply function can be used to generate new columns in a DataFrame or matrix by applying a function to the values of each row.\n\n3.  Row-wise aggregation: In data analysis, you may want to summarize or aggregate data at the row level, like calculating the mean, median, sum, or any custom function of multiple values within a row. Row-wise apply functions enable you to perform these operations efficiently.\n\n4.  Conditional computations: When dealing with complex data structures, you may need to apply different computations to different rows based on specific conditions. Row-wise apply functions can handle such cases by allowing you to implement custom logic for each row.\n\n5.  Parallel processing: Depending on the implementation, some row-wise apply functions can take advantage of parallel processing, which can significantly speed up computations on large datasets.\n\nWhen choosing to use a row-wise apply function, consider the size of your dataset, the complexity of the computation, and the available resources. As with any programming task, it's essential to balance readability, maintainability, and performance.\n:::\n\n### R-Code\n\n**Using apply for Row-wise sum**\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(\n  A = c(1, 2, 3),\n  B = c(4, 5, 6),\n  C = c(7, 8, 9)\n)\n\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  A B C\n1 1 4 7\n2 2 5 8\n3 3 6 9\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$rowsum <- apply(df, 1, sum)\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  A B C rowsum\n1 1 4 7     12\n2 2 5 8     15\n3 3 6 9     18\n```\n:::\n:::\n\n\nHere in this apply function use in build **sum** function but we use custom function also. We take a function **mul2each** sum (each number multiply with own plus 2).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmul2each <- function(x){\n  res = sum((x*x) + 2)\n  return(res)\n}\n\ndf2 <- data.frame(\n  A = c(1, 2, 3),\n  B = c(4, 5, 6),\n  C = c(7, 8, 9)\n)\n\ndf2$result <- apply(df2, 1, mul2each)\ndf2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  A B C result\n1 1 4 7     72\n2 2 5 8     99\n3 3 6 9    132\n```\n:::\n:::\n\n\nAs per requirements create a function and link this function inside the main apply function.\n\n**Using apply for Column-wise sum**\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf3 <- data.frame(\n  A = c(1, 2, 3),\n  B = c(4, 5, 6),\n  C = c(7, 8, 9)\n)\n\ncolsum <- apply(df, 2, sum)\ncolsum\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     A      B      C rowsum \n     6     15     24     45 \n```\n:::\n:::\n\n\nSimilarly as per requirements create a custom function and use it for finding column manipulation.\n\n### Python\n\n**Using apply for Row-wise sum**\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport pandas as pd\n\ndf = pd.DataFrame({\n    'A': [1, 2, 3],\n    'B': [4, 5, 6],\n    'C': [7, 8, 9]\n})\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   A  B  C\n0  1  4  7\n1  2  5  8\n2  3  6  9\n```\n:::\n:::\n\n\nCreating a custom function sum of (number \\*2 + 2)\n\n\n::: {.cell}\n\n```{.python .cell-code}\n\ndef sum_of_squares(row):\n    return sum((row**2)+2)\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nrow_sum = df.apply(sum_of_squares, axis=1)\nprint(row_sum)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0     72\n1     99\n2    132\ndtype: int64\n```\n:::\n:::\n\n\n**Using apply for Column-wise sum**\n\n\n::: {.cell}\n\n```{.python .cell-code}\ncolumn_sum = df.apply(sum_of_squares, axis=0)\nprint(column_sum)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nA     20\nB     83\nC    200\ndtype: int64\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}